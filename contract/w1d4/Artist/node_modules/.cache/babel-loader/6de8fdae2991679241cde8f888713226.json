{"ast":null,"code":"var _jsxFileName = \"/Users/vivi/Documents/Programming/project-flow/flow-dapperstarter-bootcamp/contract/w1d4/Artist/src/context/Flow.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useReducer, useEffect, useCallback } from 'react';\nimport * as fcl from '@onflow/fcl';\nimport * as FlowTypes from '@onflow/types';\nimport Picture from '../model/Picture.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Context = /*#__PURE__*/React.createContext({});\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'setUser':\n      {\n        return { ...state,\n          user: action.payload\n        };\n      }\n\n    case 'setBalance':\n      {\n        return { ...state,\n          balance: action.payload\n        };\n      }\n\n    case 'setCollection':\n      {\n        if (action.payload) {\n          return { ...state,\n            collection: action.payload.map(serialized => new Picture(serialized.pixels))\n          };\n        } else {\n          return { ...state,\n            collection: action.payload\n          };\n        }\n      }\n\n    default:\n      return state;\n  }\n}\n\nfunction Provider(props) {\n  _s();\n\n  const [state, dispatch] = useReducer(reducer, {\n    user: null,\n    balance: null,\n    collection: undefined\n  });\n  const isReady = state.balance !== null && state.collection !== undefined;\n  const fetchBalance = useCallback(async () => {\n    if (state.user.addr && state.user.addr !== '0xLocalArtist') {\n      // A sample script execution.\n      // Query for the account's FLOW token balance.\n      const balance = await fcl.send([fcl.script`\n            import FungibleToken from 0x9a0766d93b6608b7\n            import FlowToken from 0x7e60df042a9c0868\n  \n            pub fun main(address: Address): UFix64 {\n              let vaultRef = getAccount(address)\n                .getCapability(/public/flowTokenBalance)\n                .borrow<&FlowToken.Vault{FungibleToken.Balance}>()\n                ?? panic(\"Could not borrow Balance reference to the Vault\");\n  \n              return vaultRef.balance;\n            }\n          `, fcl.args([fcl.arg(state.user.addr, FlowTypes.Address)])]).then(fcl.decode);\n      dispatch({\n        type: 'setBalance',\n        payload: balance\n      });\n    } else {\n      return dispatch({\n        type: 'setBalance',\n        payload: -42\n      });\n    }\n  }, [state.user]);\n  const createCollection = useCallback(async () => {\n    const transactionId = await fcl.send([fcl.transaction`\n              import LocalArtist from 0xdced77a314381a15\n\n              transaction() {\n                prepare(account: AuthAccount) {\n                  account.save<@LocalArtist.Collection>(\n                    <- LocalArtist.createCollection(),\n                    to: /storage/LocalArtistPictureCollection\n                  )\n                  account.link<&{LocalArtist.PictureReceiver}>(\n                    /public/LocalArtistPictureReceiver,\n                    target: /storage/LocalArtistPictureCollection\n                  )\n                }\n              }\n            `, fcl.payer(fcl.authz), // current user is responsible for paying for the transaction\n    fcl.proposer(fcl.authz), // current user acting as the nonce\n    fcl.authorizations([fcl.authz]), // current user will be first AuthAccount\n    fcl.limit(9999) // set the compute limit\n    ]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed(); //return null;\n  }, []);\n  const destroyCollection = useCallback(async () => {\n    const transactionId = await fcl.send([fcl.transaction`\n              import LocalArtist from 0xdced77a314381a15\n\n              transaction() {\n                prepare(account: AuthAccount) {\n                  account.unlink(/public/LocalArtistPictureReceiver)\n                  let collection <- account.load<@LocalArtist.Collection>(\n                    from: /storage/LocalArtistPictureCollection\n                  )\n                  destroy collection\n                }\n              }\n            `, fcl.payer(fcl.authz), // current user is responsible for paying for the transaction\n    fcl.proposer(fcl.authz), // current user acting as the nonce\n    fcl.authorizations([fcl.authz]), // current user will be first AuthAccount\n    fcl.limit(9999) // set the compute limit\n    ]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed(); //return null;\n  }, []);\n  const fetchCollection = useCallback(async address => {\n    if (address || state.user.addr) {\n      try {\n        let args = null;\n\n        if (address) {\n          // eslint-disable-next-line\n          args = fcl.args([fcl.arg(address, FlowTypes.Address)]);\n        } else {\n          // eslint-disable-next-line\n          args = fcl.args([fcl.arg(state.user.addr, FlowTypes.Address)]);\n        } // TODO: Implement the getCollections.cdc script using \"fcl.script\", and\n        // the \"args\" in place for the script's arguments.\n        // Use the \"fetchBalance\" as an example.\n        // const collection = [];\n\n\n        const collection = await fcl.send([fcl.script`\n              import LocalArtist from 0xdced77a314381a15\n\n              pub fun main(address: Address): [LocalArtist.Canvas] {\n                let account = getAccount(address)\n                let pictureReceiverRef = account\n                  .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                  .borrow()\n                  ?? panic(\"Couldn't borrow Picture Receiver reference.\")\n              \n                return pictureReceiverRef.getCanvases()\n              }\n            `, fcl.args([fcl.arg(state.user.addr, FlowTypes.Address)])]).then(fcl.decode);\n\n        if (address) {\n          return collection.map(serialized => new Picture(serialized.pixels));\n        } else {\n          dispatch({\n            type: 'setCollection',\n            payload: collection\n          });\n        }\n      } catch (error) {\n        if (address) {\n          return null;\n        } else {\n          dispatch({\n            type: 'setCollection',\n            payload: null\n          });\n        }\n      }\n    }\n  }, [state.user]);\n  const printPicture = useCallback(async picture => {\n    const transactionId = await fcl.send([fcl.transaction`\n              import LocalArtist from 0xdced77a314381a15\n\n              transaction(width: Int, height: Int, pixels: String) {\n  \n                let picture: @LocalArtist.Picture?\n                let collectionRef: &{LocalArtist.PictureReceiver}\n              \n                prepare(account: AuthAccount) {\n                  // TODO: Change to your contract account address.\n                  let printerRef = getAccount(0xdced77a314381a15)\n                    .getCapability<&LocalArtist.Printer>(/public/LocalArtistPicturePrinter)\n                    .borrow()\n                    ?? panic(\"Couldn't borrow printer reference.\")\n                    \n                  self.picture <- printerRef.print(\n                    width: width,\n                    height: height,\n                    pixels: pixels\n                  )\n                  self.collectionRef = account\n                    .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                    .borrow()\n                    ?? panic(\"Couldn't borrow picture receiver reference.\")\n                }\n                execute {\n                  if self.picture == nil {\n                    destroy self.picture\n                  } else {\n                    self.collectionRef.deposit(picture: <- self.picture!)\n                  }\n                }\n              }\n            `, fcl.args([fcl.arg(5, FlowTypes.Int), fcl.arg(5, FlowTypes.Int), fcl.arg(state.picture.pixels, FlowTypes.String)]), fcl.payer(fcl.authz), // current user is responsible for paying for the transaction\n    fcl.proposer(fcl.authz), // current user acting as the nonce\n    fcl.authorizations([fcl.authz]), // current user will be first AuthAccount\n    fcl.limit(9999) // set the compute limit\n    ]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed(); //return null;\n  }, [flow.state.picture]);\n\n  const setUser = user => {\n    dispatch({\n      type: 'setUser',\n      payload: user\n    });\n  };\n\n  const logIn = () => {\n    fcl.logIn();\n  };\n\n  const logOut = () => {\n    fcl.unauthenticate(); // Log out.\n  };\n\n  useEffect(() => {\n    fcl.currentUser().subscribe(setUser);\n  }, []);\n  useEffect(() => {\n    if (state.user && state.user.addr) {\n      fetchBalance();\n      fetchCollection();\n    }\n  }, [state.user, fetchBalance, fetchCollection]);\n  return /*#__PURE__*/_jsxDEV(Context.Provider, {\n    value: {\n      state,\n      isReady,\n      dispatch,\n      logIn,\n      logOut,\n      fetchBalance,\n      fetchCollection,\n      createCollection,\n      destroyCollection,\n      printPicture\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 287,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Provider, \"b9cKHgeZd2mpULmX3NAN/nsibVI=\");\n\n_c = Provider;\nexport { Context as default, Provider };\n\nvar _c;\n\n$RefreshReg$(_c, \"Provider\");","map":{"version":3,"sources":["/Users/vivi/Documents/Programming/project-flow/flow-dapperstarter-bootcamp/contract/w1d4/Artist/src/context/Flow.jsx"],"names":["React","useReducer","useEffect","useCallback","fcl","FlowTypes","Picture","Context","createContext","reducer","state","action","type","user","payload","balance","collection","map","serialized","pixels","Provider","props","dispatch","undefined","isReady","fetchBalance","addr","send","script","args","arg","Address","then","decode","createCollection","transactionId","transaction","payer","authz","proposer","authorizations","limit","tx","onceSealed","destroyCollection","fetchCollection","address","error","printPicture","picture","Int","String","flow","setUser","logIn","logOut","unauthenticate","currentUser","subscribe","children","default"],"mappings":"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","sourcesContent":["import React, {useReducer, useEffect, useCallback} from 'react';\nimport * as fcl from '@onflow/fcl';\nimport * as FlowTypes from '@onflow/types';\n\nimport Picture from '../model/Picture.js';\n\nconst Context = React.createContext({});\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'setUser': {\n      return {\n        ...state,\n        user: action.payload\n      };\n    }\n    case 'setBalance': {\n      return {\n        ...state,\n        balance: action.payload\n      };\n    }\n    case 'setCollection': {\n      if (action.payload) {\n        return {\n          ...state,\n          collection: action.payload.map((serialized) => new Picture(serialized.pixels))\n        };\n      } else {\n        return {\n          ...state,\n          collection: action.payload\n        };\n      }\n    }\n    default:\n      return state;\n  }\n}\n\nfunction Provider(props) {\n  const [state, dispatch] = useReducer(reducer, {\n    user: null,\n    balance: null,\n    collection: undefined\n  });\n\n  const isReady = (\n    state.balance !== null &&\n    state.collection !== undefined\n  );\n\n  const fetchBalance = useCallback(\n    async () => {\n      if (state.user.addr && state.user.addr !== '0xLocalArtist') {\n        // A sample script execution.\n        // Query for the account's FLOW token balance.\n        const balance = await fcl.send([\n          fcl.script`\n            import FungibleToken from 0x9a0766d93b6608b7\n            import FlowToken from 0x7e60df042a9c0868\n  \n            pub fun main(address: Address): UFix64 {\n              let vaultRef = getAccount(address)\n                .getCapability(/public/flowTokenBalance)\n                .borrow<&FlowToken.Vault{FungibleToken.Balance}>()\n                ?? panic(\"Could not borrow Balance reference to the Vault\");\n  \n              return vaultRef.balance;\n            }\n          `,\n          fcl.args([\n            fcl.arg(state.user.addr, FlowTypes.Address)\n          ])\n        ]).then(fcl.decode);\n\n        dispatch({type: 'setBalance', payload: balance});\n      } else {\n        return dispatch({type: 'setBalance', payload: -42});\n      }\n    },\n    [state.user]\n  );\n  const createCollection = useCallback(\n    async () => {        \n        \n        const transactionId = await fcl\n          .send([\n            fcl.transaction`\n              import LocalArtist from 0xdced77a314381a15\n\n              transaction() {\n                prepare(account: AuthAccount) {\n                  account.save<@LocalArtist.Collection>(\n                    <- LocalArtist.createCollection(),\n                    to: /storage/LocalArtistPictureCollection\n                  )\n                  account.link<&{LocalArtist.PictureReceiver}>(\n                    /public/LocalArtistPictureReceiver,\n                    target: /storage/LocalArtistPictureCollection\n                  )\n                }\n              }\n            `,            \n            fcl.payer(fcl.authz), // current user is responsible for paying for the transaction\n            fcl.proposer(fcl.authz), // current user acting as the nonce\n            fcl.authorizations([fcl.authz]), // current user will be first AuthAccount\n            fcl.limit(9999), // set the compute limit\n          ])\n          .then(fcl.decode);\n        return fcl.tx(transactionId).onceSealed();\n        \n      \n        //return null;\n    },\n    []\n  );\n  const destroyCollection = useCallback(\n    async () => {      \n      const transactionId = await fcl\n        .send([\n          fcl.transaction`\n              import LocalArtist from 0xdced77a314381a15\n\n              transaction() {\n                prepare(account: AuthAccount) {\n                  account.unlink(/public/LocalArtistPictureReceiver)\n                  let collection <- account.load<@LocalArtist.Collection>(\n                    from: /storage/LocalArtistPictureCollection\n                  )\n                  destroy collection\n                }\n              }\n            `,\n            fcl.payer(fcl.authz), // current user is responsible for paying for the transaction\n            fcl.proposer(fcl.authz), // current user acting as the nonce\n            fcl.authorizations([fcl.authz]), // current user will be first AuthAccount\n            fcl.limit(9999), // set the compute limit\n        ])\n        .then(fcl.decode);\n      return fcl.tx(transactionId).onceSealed();\n      \n\n      //return null;\n    },\n    []\n  );\n\n  const fetchCollection = useCallback(\n    async (address) => {\n      if (address || state.user.addr) {\n        try {\n          let args = null;\n          if (address) {\n            // eslint-disable-next-line\n            args = fcl.args([\n              fcl.arg(address, FlowTypes.Address)\n            ]);\n          } else {\n            // eslint-disable-next-line\n            args = fcl.args([\n              fcl.arg(state.user.addr, FlowTypes.Address)\n            ]);\n          }\n          \n          // TODO: Implement the getCollections.cdc script using \"fcl.script\", and\n          // the \"args\" in place for the script's arguments.\n          // Use the \"fetchBalance\" as an example.\n\n         // const collection = [];\n\n          const collection = await fcl.send([\n            fcl.script`\n              import LocalArtist from 0xdced77a314381a15\n\n              pub fun main(address: Address): [LocalArtist.Canvas] {\n                let account = getAccount(address)\n                let pictureReceiverRef = account\n                  .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                  .borrow()\n                  ?? panic(\"Couldn't borrow Picture Receiver reference.\")\n              \n                return pictureReceiverRef.getCanvases()\n              }\n            `,\n            fcl.args([\n              fcl.arg(state.user.addr, FlowTypes.Address)\n            ])\n          ]).then(fcl.decode);\n\n\n          if (address) {\n            return collection.map((serialized) => new Picture(serialized.pixels));\n          } else {\n            dispatch({type: 'setCollection', payload: collection});\n          }\n        } catch (error) {\n          if (address) {\n            return null;\n          } else {\n            dispatch({type: 'setCollection', payload: null});\n          }\n        }\n      }\n    },\n    [state.user]\n  );\n  const printPicture = useCallback(\n    async (picture) => {\n      \n      const transactionId = await fcl\n        .send([\n          fcl.transaction`\n              import LocalArtist from 0xdced77a314381a15\n\n              transaction(width: Int, height: Int, pixels: String) {\n  \n                let picture: @LocalArtist.Picture?\n                let collectionRef: &{LocalArtist.PictureReceiver}\n              \n                prepare(account: AuthAccount) {\n                  // TODO: Change to your contract account address.\n                  let printerRef = getAccount(0xdced77a314381a15)\n                    .getCapability<&LocalArtist.Printer>(/public/LocalArtistPicturePrinter)\n                    .borrow()\n                    ?? panic(\"Couldn't borrow printer reference.\")\n                    \n                  self.picture <- printerRef.print(\n                    width: width,\n                    height: height,\n                    pixels: pixels\n                  )\n                  self.collectionRef = account\n                    .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                    .borrow()\n                    ?? panic(\"Couldn't borrow picture receiver reference.\")\n                }\n                execute {\n                  if self.picture == nil {\n                    destroy self.picture\n                  } else {\n                    self.collectionRef.deposit(picture: <- self.picture!)\n                  }\n                }\n              }\n            `,\n            fcl.args([\n              fcl.arg(5, FlowTypes.Int),\n              fcl.arg(5, FlowTypes.Int),\n              fcl.arg(state.picture.pixels, FlowTypes.String),\n            ]),\n            fcl.payer(fcl.authz), // current user is responsible for paying for the transaction\n            fcl.proposer(fcl.authz), // current user acting as the nonce\n            fcl.authorizations([fcl.authz]), // current user will be first AuthAccount\n            fcl.limit(9999), // set the compute limit\n        ])\n        .then(fcl.decode);\n      return fcl.tx(transactionId).onceSealed();      \n\n      //return null;\n    },\n    [flow.state.picture]\n  );\n\n  const setUser = (user) => {\n    dispatch({type: 'setUser', payload: user});\n  };\n  const logIn = () => {\n    fcl.logIn();\n  };\n  const logOut = () => {\n    fcl.unauthenticate(); // Log out.\n  };\n\n  useEffect(() => {\n    fcl.currentUser().subscribe(setUser);\n  }, []);\n\n  useEffect(() => {\n    if (state.user && state.user.addr) {\n      fetchBalance();\n      fetchCollection();\n    }\n  }, [state.user, fetchBalance, fetchCollection]);\n\n  return (\n    <Context.Provider\n      value={{\n        state,\n        isReady,\n        dispatch,\n        logIn,\n        logOut,\n        fetchBalance,\n        fetchCollection,\n        createCollection,\n        destroyCollection,\n        printPicture\n      }}\n    >\n      {props.children}\n    </Context.Provider>\n  );\n}\n\nexport {\n  Context as default,\n  Provider\n};"]},"metadata":{},"sourceType":"module"}